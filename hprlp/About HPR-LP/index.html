

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>About HPR-LP &mdash; HPR-LP</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../_static/custom.css?v=efd90ad8" />
      <link rel="stylesheet" type="text/css" href="../_static/fonts.css?v=5583d106" />
      <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/pseudocode@latest/build/pseudocode.min.css" />
      <link rel="stylesheet" type="text/css" href="../_static/custom.css?v=efd90ad8" />

  
      <script src="../_static/jquery.js?v=5d32c60e"></script>
      <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../_static/documentation_options.js?v=5929fcd5"></script>
      <script src="../_static/doctools.js?v=9a2dae69"></script>
      <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script src="https://cdn.jsdelivr.net/npm/pseudocode@latest/build/pseudocode.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.js"></script>
      <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "displayMath": [["$$", "$$"], ["\\[", "\\]"]]}, "options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
      <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
      <script src="../_static/back_to_hpr_fab.js?v=1776d9ad"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Quick start guide" href="../Quick%20start%20guide/index.html" />
    <link rel="prev" title="HPR-LP Solver" href="../index.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            HPR-LP
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">About HPR-LP</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#problem-statement">Problem statement</a></li>
<li class="toctree-l2"><a class="reference internal" href="#hpr-method-for-lp">HPR method for LP</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#base-algorithm">Base algorithm</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#algorithmic-enhancements">Algorithmic enhancements</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#restart-strategy">Restart strategy</a></li>
<li class="toctree-l3"><a class="reference internal" href="#update-rules-for-sigma">Update rules for <span class="math notranslate nohighlight">\(\sigma\)</span></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#gpu-implementation">GPU Implementation</a></li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Quick%20start%20guide/index.html">Quick start guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Interfaces/index.html">Interfaces</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Benchmarks/index.html">Benchmarks</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Releases/index.html">Releases</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Contributing.html">Contributing</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Citing%20HPR-LP.html">Citing HPR-LP</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">HPR-LP</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">About HPR-LP</li>
  <li class="wy-breadcrumbs-aside">
    <a href="https://github.com/PolyU-IOR/HPR-LP" target="_blank" rel="noopener">
      <svg class="gh-icon" viewBox="0 0 16 16" width="20" height="20" aria-hidden="true">
        <path fill="currentColor" fill-rule="evenodd"
          d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 
             5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49
             -2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13
             -.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 
             1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07
             -1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15
             -.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82
             .64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27
             1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12
             .51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 
             3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 
             2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42
             -3.58-8-8-8z">
        </path>
      </svg>
      GitHub
    </a>
  </li>

  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section class="tex2jax_ignore mathjax_ignore" id="about-hpr-lp">
<h1>About HPR-LP</h1>
<p>HPR-LP is a GPU-accelerated solver for large-scale linear programming (LP). It is based on the Halpern Peaceman–Rachford (HPR) method with an adaptive restart strategy for stability and speed.</p>
<!-- ```{toctree}
:maxdepth: 1
:caption: About HPR-LP

Problem statement
HPR method for LP
Algorithmic enhancements
Implementations
``` -->
<section id="problem-statement">
<h2>Problem statement</h2>
<p><strong>Problem form.</strong> The general LP solved by HPR-LP is:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
\min_{x \in \mathbb{R}^n} &amp; \;\; \langle c, x \rangle \\
\text{s.t.} \;\; &amp; Ax \in \mathcal{K}, \\
&amp; x \in \mathcal{C},
\end{aligned}\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(c \in \mathbb{R}^n\)</span> is the objective vector, <span class="math notranslate nohighlight">\(A \in \mathbb{R}^{m \times n}\)</span> is the constraint matrix,<br />
<span class="math notranslate nohighlight">\(\mathcal{K} := \{ s \in \mathbb{R}^m : l_c \leq s \leq u_c \}\)</span> with bounds <span class="math notranslate nohighlight">\(l_c \in (\mathbb{R} \cup \{-\infty\})^m\)</span> and <span class="math notranslate nohighlight">\(u_c \in (\mathbb{R} \cup \{\infty\})^m\)</span>,<br />
and <span class="math notranslate nohighlight">\(\mathcal{C} := \{ x \in \mathbb{R}^n : l_v \leq x \leq u_v \}\)</span> with bounds <span class="math notranslate nohighlight">\(l_v \in (\mathbb{R} \cup \{-\infty\})^n\)</span> and <span class="math notranslate nohighlight">\(u_v \in (\mathbb{R} \cup \{\infty\})^n\)</span>.</p>
<p><strong>Dual form.</strong> The corresponding dual problem is:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
\min_{y \in \mathbb{R}^m, \; z \in \mathbb{R}^n} &amp; \;\; \delta_{\mathcal{K}}^*(-y) + \delta_{\mathcal{C}}^*(-z) \\
\text{s.t.} \;\; &amp; A^* y + z = c,
\end{aligned}\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(\delta_S^*(\cdot)\)</span> denotes the convex conjugate of the indicator function <span class="math notranslate nohighlight">\(\delta_S(\cdot)\)</span> associated with a closed convex set <span class="math notranslate nohighlight">\(S\)</span>.</p>
</section>
<section id="hpr-method-for-lp">
<h2>HPR method for LP</h2>
<p>HPR-LP is based on the Halpern–Peaceman–Rachford (HPR) method for linear programming. The base algorithm appears below, followed by its convergence guarantees and complexity properties, which in turn motivate the algorithmic enhancements described later.</p>
<section id="base-algorithm">
<h3>Base algorithm</h3>
<p>For any <span class="math notranslate nohighlight">\((y, z, x) \in \mathbb{R}^m \times \mathbb{R}^n \times \mathbb{R}^n\)</span>, the augmented Lagrangian of the dual problem is</p>
<div class="math notranslate nohighlight">
\[L_\sigma(y, z; x) := \delta_{\mathcal{K}}^*(-y) + \delta_{\mathcal{C}}^*(-z)
+ \langle x, A^* y + z - c \rangle
+ \frac{\sigma}{2} \| A^* y + z - c \|^2,\]</div>
<p>where <span class="math notranslate nohighlight">\(\sigma &gt; 0\)</span> is a penalty parameter. For notational convenience, let <span class="math notranslate nohighlight">\(w := (y, z, x) \in \mathbb{W} := \mathbb{R}^m \times \mathbb{R}^n \times \mathbb{R}^n\)</span>. Then, an HPR method with semi-proximal terms for solving the above problems is summarized in Algorithm 1.</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{array}{|l|}
\hline
\textbf{Algorithm 1: An HPR method with semi-proximal terms} \\ \hline
\textbf{Input:}\
\text{Set the penalty parameter }\sigma&gt;0.\ \\
\text{Let }\mathcal{T}_1:\mathbb{R}^m\to\mathbb{R}^m\ \text{be a self-adjoint positive semidefinite linear operator such that } \\
\mathcal{T}_1+\sigma A A^*\ \text{is positive definite. } 
\text{Denote } w=(y,z,x)\ \text{and }\bar{w}=(\bar{y},\bar{z},\bar{x}).\ \\
\text{Choose an initial point } w^0=(y^0,z^0,x^0)\in\mathbb{R}^m\times\mathbb{R}^n\times\mathbb{R}^n. \\ 
\textbf{for } k = 0,1,\ldots \ \textbf{do} \\ 
\quad \text{Step 1: } \ \bar{z}^{k+1} = \arg\min_{z \in \mathbb{R}^n} L_\sigma(y^k, z; x^k); \\ 
\quad \text{Step 2: } \ \bar{x}^{k+1} = x^k + \sigma(A^* y^k + \bar{z}^{k+1} - c); \\ 
\quad \text{Step 3: } \ \bar{y}^{k+1} = \arg\min_{y \in \mathbb{R}^m} 
   \left\{ L_\sigma(y, \bar{z}^{k+1}; \bar{x}^{k+1}) 
   + \tfrac{\sigma}{2}\|y-y^k\|_{\mathcal{T}_1}^2 \right\}; \\ 
\quad \text{Step 4: } \ \hat{w}^{k+1} = 2\bar{w}^{k+1} - w^k; \\ 
\quad \text{Step 5: } \ w^{k+1} = \tfrac{1}{k+2} w^0 + \tfrac{k+1}{k+2} \hat{w}^{k+1}; \\ 
\textbf{end for} \\ 
\textbf{Output:} \text{Iteration sequence } \{ \bar{w}^k \}. \\ \hline
\end{array}\end{split}\]</div>
<p><strong>Remark.</strong> Steps 1–3 match the Douglas–Rachford (DR) updates. Step 4 applies the Peaceman–Rachford (PR) relaxation, and Step 5 adds a Halpern step with step size <span class="math notranslate nohighlight">\(1/(k+2)\)</span>. Together, Algorithm 1 behaves like an accelerated, preconditioned ADMM-type method (pADMM) with <span class="math notranslate nohighlight">\(\alpha=2\)</span>.</p>
<p>An optimal dual pair <span class="math notranslate nohighlight">\((y^*,z^*)\)</span> exists if there is <span class="math notranslate nohighlight">\(x^*\in\mathbb{R}^n\)</span> such that <span class="math notranslate nohighlight">\((y^*,z^*,x^*)\)</span> satisfies the following KKT system:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
0 &amp;\in A x^* - \partial \delta_{\mathcal{K}}^*(-y^*), \\
0 &amp;\in x^* - \partial \delta_{\mathcal{C}}^*(-z^*), \\
&amp;\quad A^* y^* + z^* - c = 0.
\end{aligned}\end{split}\]</div>
<p><strong>Assumption 1</strong> <em>There exists a vector <span class="math notranslate nohighlight">\((y^*, z^*, x^*) \in \mathbb{R}^m \times \mathbb{R}^n \times \mathbb{R}^n\)</span> satisfying the KKT system above.</em></p>
<p>Under Assumption 1, the primal–dual problem is equivalent to finding <span class="math notranslate nohighlight">\(w^*\)</span> with <span class="math notranslate nohighlight">\(0 \in \mathcal{T}w^*\)</span>, where the maximal monotone operator <span class="math notranslate nohighlight">\(\mathcal{T}\)</span> is</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mathcal{T} w =
\begin{pmatrix}
- \partial \delta_{\mathcal{K}}^*(-y) + A x \\
- \partial \delta_{\mathcal{C}}^*(-z) + x \\
c - A^* y - z
\end{pmatrix},
\quad
\forall w = (y, z, x) \in \mathbb{R}^m \times \mathbb{R}^n \times \mathbb{R}^n.\end{split}\]</div>
<p>The global convergence of Algorithm 1 is established in the following proposition.</p>
<p><strong>Proposition 2</strong>. <em>Suppose that Assumption 1 holds. Then the sequence <span class="math notranslate nohighlight">\(\{\bar{w}^k\} = \{(\bar{y}^k, \bar{z}^k, \bar{x}^k)\}\)</span> generated by the HPR method with semi-proximal terms in Algorithm 1 converges to a point <span class="math notranslate nohighlight">\(w^* = (y^*, z^*, x^*)\)</span>, where <span class="math notranslate nohighlight">\((y^*, z^*)\)</span> solves the dual problem and <span class="math notranslate nohighlight">\(x^*\)</span> solves the primal problem.</em></p>
<p>For the complexity analysis, define the self-adjoint positive semidefinite operator <span class="math notranslate nohighlight">\(\mathcal{M}:\mathbb{R}^m \times \mathbb{R}^n \times \mathbb{R}^n \to \mathbb{R}^m \times \mathbb{R}^n \times \mathbb{R}^n\)</span> as</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mathcal{M} =
\begin{bmatrix}
\sigma A A^* + \sigma \mathcal{T}_1 &amp; 0 &amp; A \\
0 &amp; 0 &amp; 0 \\
A^* &amp; 0 &amp; \tfrac{1}{\sigma} I_n
\end{bmatrix},\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(I_n\)</span> is the <span class="math notranslate nohighlight">\(n\times n\)</span> identity. Two quantities are tracked: the KKT residual and the objective error. The residual map is</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mathcal{R}(w) =
\begin{pmatrix}
A x - \Pi_{\mathcal{K}}(A x - y) \\
x - \Pi_{\mathcal{C}}(x - z) \\
c - A^* y - z
\end{pmatrix},
\quad
\forall w = (y, z, x) \in \mathbb{R}^m \times \mathbb{R}^n \times \mathbb{R}^n.\end{split}\]</div>
<p>Let <span class="math notranslate nohighlight">\(\{(\bar{y}^k,\bar{z}^k)\}\)</span> be generated by Algorithm 1. Define the objective error as</p>
<div class="math notranslate nohighlight">
\[h(\bar{y}^{k+1}, \bar{z}^{k+1})
:= \delta_{\mathcal{K}}^*(-\bar{y}^{k+1}) + \delta_{\mathcal{C}}^*(-\bar{z}^{k+1})
- \delta_{\mathcal{K}}^*(-y^*) - \delta_{\mathcal{C}}^*(-z^*),
\quad \forall k \geq 0,\]</div>
<p>where <span class="math notranslate nohighlight">\((y^*, z^*)\)</span> is the limit point of the sequence <span class="math notranslate nohighlight">\(\{(\bar{y}^k, \bar{z}^k)\}\)</span>.<br />
The complexity of the HPR method with semi-proximal terms is summarized in the following theorem.</p>
<p><strong>Theorem 3</strong>  <em>Suppose that Assumption 1 holds. Let <span class="math notranslate nohighlight">\(\{w^k\} = \{(y^k, z^k, x^k)\}\)</span> and <span class="math notranslate nohighlight">\(\{\bar{w}^k\} = \{(\bar{y}^k, \bar{z}^k, \bar{x}^k)\}\)</span> be two sequences generated by the HPR method with semi-proximal terms in Algorithm 1, and let <span class="math notranslate nohighlight">\(w^* = (y^*, z^*, x^*)\)</span> be its limit point. Define <span class="math notranslate nohighlight">\(R_0 = \|w^0 - w^*\|_{\mathcal{M}}\)</span>. Then for all <span class="math notranslate nohighlight">\(k \geq 0\)</span>, the following iteration complexity bounds hold:</em></p>
<div class="math notranslate nohighlight">
\[\| \bar{w}^k - \hat{w}^{k+1} \|_{\mathcal{M}} \leq \frac{R_0}{k+1},\]</div>
<div class="math notranslate nohighlight">
\[\| \mathcal{R}(\bar{w}^{k+1}) \|
\leq \left( \frac{\sigma(\|A\| + \| \sqrt{\mathcal{T}_1} \|) + 1}{\sqrt{\sigma}} \right) \frac{R_0}{k+1},\]</div>
<div class="math notranslate nohighlight">
\[- \frac{1}{\sqrt{\sigma}} \| x^* \| \frac{R_0}{k+1}
\;\; \leq \;\;
h(\bar{y}^{k+1}, \bar{z}^{k+1})
\;\; \leq \;\;
\left( 3 R_0 + \frac{1}{\sqrt{\sigma}} \| x^* \| \right) \frac{R_0}{k+1}.\]</div>
<!-- The results above establish that the HPR method enjoys global convergence and an $O(1/k)$ complexity rate in terms of both KKT residuals and objective error. These properties motivate the use of restart strategies and adaptive parameter updates, which will be reviewed in the next subsection. -->
</section>
</section>
<section id="algorithmic-enhancements">
<h2>Algorithmic enhancements</h2>
<p>To boost performance on LP (and CCQP), HPR uses two key enhancements: <strong>restart strategies</strong> and <strong>adaptive updates of the penalty <span class="math notranslate nohighlight">\(\sigma\)</span></strong>. These are motivated by the <span class="math notranslate nohighlight">\(O(1/k)\)</span> bounds in Theorem 3. For completeness, Algorithm 2 shows the full HPR-LP framework.</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{array}{|l|}
\hline
\textbf{Algorithm 2  HPR-LP: A Halpern Peaceman-Rachford method} \\ \textbf{for the problem} \\ \hline
\textbf{Input:} \ \mathcal{T}_1:\mathbb{R}^m\to\mathbb{R}^m\ \text{be a self-adjoint positive semidefinite linear operator such that}\\ \mathcal{T}_1+\sigma AA^* \text{ is positive definite}. \text{ Denote }w=(y,z,x),\ \bar{w}=(\bar{y},\bar{z},\bar{x}).\ \text{Choose an initial}\\ \text{point } w^{0,0}=(y^{0,0},z^{0,0},x^{0,0})\in\mathbb{R}^m\times\mathbb{R}^n\times\mathbb{R}^n. \\ 
\textbf{Initialization:}\ \text{Set the outer loop counter }r=0,\ \text{the total loop counter }k=0,\ \\ \text{and the initial penalty parameter }\sigma_0&gt;0. \\ 
\textbf{repeat} \\ 
\quad \text{initialize the inner loop: set inner loop counter }t=0; \\ 
\quad \textbf{repeat} \\ 
\quad\quad \bar{z}^{r,t+1}=\arg\min_{z\in\mathbb{R}^n}\{L_{\sigma_r}(y^{r,t},z;x^{r,t})\}; \\ 
\quad\quad \bar{x}^{r,t+1}=x^{r,t}+\sigma_r(A^*y^{r,t}+\bar{z}^{r,t+1}-c); \\ 
\quad\quad \bar{y}^{r,t+1}=\arg\min_{y\in\mathbb{R}^m}\{L_{\sigma_r}(y,\bar{z}^{r,t+1};\bar{x}^{r,t+1})+\tfrac{\sigma_r}{2}\|y-y^{r,t}\|_{\mathcal{T}_1}^2\}; \\ 
\quad\quad \hat{w}^{r,t+1}=2\bar{w}^{r,t+1}-w^{r,t}; \\ 
\quad\quad w^{r,t+1}=\tfrac{1}{t+2}w^{r,0}+\tfrac{t+1}{t+2}\hat{w}^{r,t+1}; \\ 
\quad\quad t=t+1,\ k=k+1; \\ 
\quad \textbf{until}\ \text{one of the restart criteria holds or termination criteria hold} \\ 
\quad \textbf{restart the inner loop: }\tau_r=t,\ w^{r+1,0}=w^{r,\tau_r}, \\ 
\quad \sigma_{r+1}=\textbf{SigmaUpdate}(\bar{w}^{r,\tau_r},w^{r,0},\mathcal{T}_1,A),\ r=r+1; \\ 
\textbf{until}\ \text{termination criteria hold} \\ 
\textbf{Output:}\ \{\bar{w}^{r,t}\}. \\ \hline
\end{array}\end{split}\]</div>
<section id="restart-strategy">
<h3>Restart strategy</h3>
<p>Restarting plays a central role in Halpern iterations. The complexity bound depends on the initial anchor distance <span class="math notranslate nohighlight">\(R_0\)</span>. As the iterates move closer to the solution, keeping a far-away anchor becomes inefficient. Resetting the anchor to the current iterate tightens the bound and improves late-stage progress.</p>
<p>This motivates the merit function</p>
<div class="math notranslate nohighlight">
\[R_{r,t} := \| w^{r,t} - w^* \|_{\mathcal{M}}, 
\quad \forall r \geq 0,\; t \geq 0,\]</div>
<p>where <span class="math notranslate nohighlight">\(w^*\)</span> is any solution of the KKT system. Since <span class="math notranslate nohighlight">\(w^*\)</span> is unknown, the practical surrogate</p>
<div class="math notranslate nohighlight">
\[\tilde{R}_{r,t} := \| w^{r,t} - \hat{w}^{r,t+1} \|_{\mathcal{M}}\]</div>
<p>is employed in defining restart rules. The following criteria are commonly adopted:</p>
<ol class="arabic simple">
<li><p><strong>Sufficient decay:</strong></p></li>
</ol>
<div class="math notranslate nohighlight">
\[\tilde{R}_{r,t+1} \leq \alpha_1 \tilde{R}_{r,0},\]</div>
<ol class="arabic simple" start="2">
<li><p><strong>Necessary decay + no local progress:</strong></p></li>
</ol>
<div class="math notranslate nohighlight">
\[\tilde{R}_{r,t+1} \leq \alpha_2 \tilde{R}_{r,0}, 
\quad \text{and} \quad
\tilde{R}_{r,t+1} &gt; \tilde{R}_{r,t};\]</div>
<ol class="arabic simple" start="3">
<li><p><strong>Long inner loop:</strong></p></li>
</ol>
<div class="math notranslate nohighlight">
\[t \geq \alpha_3 k;\]</div>
<p>where <span class="math notranslate nohighlight">\(0 &lt; \alpha_1 &lt; \alpha_2 &lt; 1\)</span> and <span class="math notranslate nohighlight">\(0 &lt; \alpha_3 &lt; 1\)</span>. When any criterion is met, the inner loop restarts with <span class="math notranslate nohighlight">\(w^{r+1,0}=\bar{w}^{r,\tau_r}\)</span> and an updated <span class="math notranslate nohighlight">\(\sigma_{r+1}\)</span>.</p>
</section>
<section id="update-rules-for-sigma">
<h3>Update rules for <span class="math notranslate nohighlight">\(\sigma\)</span></h3>
<p>The penalty parameter <span class="math notranslate nohighlight">\(\sigma\)</span> is updated at restart points to tighten the bound and reduce residuals. Ideally, <span class="math notranslate nohighlight">\(\sigma\)</span> is chosen to minimize the weighted distance to the solution:</p>
<div class="math notranslate nohighlight">
\[\sigma_{r+1} := \arg\min_\sigma \| w^{r+1,0} - w^* \|_{\mathcal{M}}^2,\]</div>
<p>where <span class="math notranslate nohighlight">\(w^*\)</span> is any solution of the KKT system.<br />
Substituting the definition of <span class="math notranslate nohighlight">\(\mathcal{M}\)</span> leads to the closed-form expression</p>
<div class="math notranslate nohighlight">
\[\sigma_{r+1} =
\sqrt{
\frac{\| x^{r+1,0} - x^* \|^2}
{\| y^{r+1,0} - y^* \|_{\mathcal{T}_1}^2 + \| A^*(y^{r+1,0} - y^*) \|^2}
}.\]</div>
<p>Since <span class="math notranslate nohighlight">\((x^*,y^*)\)</span> are unknown, observable progress is used instead:</p>
<div class="math notranslate nohighlight">
\[\Delta_x := \| \bar{x}^{r,\tau_r} - x^{r,0} \|, 
\quad
\Delta_y := \sqrt{ \| \bar{y}^{r,\tau_r} - y^{r,0} \|_{\mathcal{T}_1}^2 + \| A^*(\bar{y}^{r,\tau_r} - y^{r,0}) \|^2 },\]</div>
<p>which yields the implementable update rule</p>
<div class="math notranslate nohighlight">
\[\sigma_{r+1} = \frac{\Delta_x}{\Delta_y}.\]</div>
<p>Several special cases of <span class="math notranslate nohighlight">\(\mathcal{T}_1\)</span> are listed below:</p>
<ol class="arabic">
<li><p><strong>Case <span class="math notranslate nohighlight">\(\mathcal{T}_1 = 0\)</span>.</strong><br />
This case occurs when <span class="math notranslate nohighlight">\(l_c = u_c = b\)</span>, which arises in applications with special structure in <span class="math notranslate nohighlight">\(A\)</span>. The <span class="math notranslate nohighlight">\(y\)</span>-update then reduces to solving the linear system</p>
<div class="math notranslate nohighlight">
\[A A^* \bar{y}^{r,t+1} = \frac{1}{\sigma_r} \big( b - A(\bar{x}^{r,t+1} + \sigma_r(\bar{z}^{r,t+1} - c)) \big),\]</div>
<p>which is computationally affordable in practice. In this case, the update rule simplifies to</p>
<div class="math notranslate nohighlight">
\[\sigma_{r+1} = \frac{\| \bar{x}^{r,\tau_r} - x^{r,0} \|}{\| A^*(\bar{y}^{r,\tau_r} - y^{r,0}) \|}.\]</div>
</li>
<li><p><strong>Case <span class="math notranslate nohighlight">\(\mathcal{T}_1 = \lambda_A I_m - A A^*\)</span> with <span class="math notranslate nohighlight">\(\lambda_A \geq \|A\|_2^2\)</span>.</strong><br />
This choice applies when <span class="math notranslate nohighlight">\(l_c \neq u_c\)</span> or when solving the system in case 1 is too expensive. The <span class="math notranslate nohighlight">\(y\)</span>-update takes the form</p>
<div class="math notranslate nohighlight">
\[\bar{y}^{r,t+1} = \frac{1}{\sigma_r \lambda_A} \Big( \Pi_{\mathcal{K}}(R_y) - R_y \Big),\]</div>
<p>where <span class="math notranslate nohighlight">\(R_y := A(2\bar{x}^{r,t+1} - x^{r,t}) - \sigma_r \lambda_A y^{r,t}\)</span>. In this setting, the update for <span class="math notranslate nohighlight">\(\sigma\)</span> becomes</p>
<div class="math notranslate nohighlight">
\[\sigma_{r+1} = \frac{\| \bar{x}^{r,\tau_r} - x^{r,0} \|}{\sqrt{\lambda_A} \; \| \bar{y}^{r,\tau_r} - y^{r,0} \|}.\]</div>
</li>
</ol>
<p>Note that <span class="math notranslate nohighlight">\(\Delta_x\)</span> and <span class="math notranslate nohighlight">\(\Delta_y\)</span> may deviate significantly from the true quantities.</p>
</section>
</section>
<section id="gpu-implementation">
<h2>GPU Implementation</h2>
<p>We first present the update formulas for each subproblem in HPR-LP. Specifically, for any <span class="math notranslate nohighlight">\(r\ge 0\)</span> and <span class="math notranslate nohighlight">\(t\ge 0\)</span>, the update of <span class="math notranslate nohighlight">\(z^{r,t+1}\)</span> is:</p>
<div class="math notranslate nohighlight">
\[z^{r,t+1}
= \arg\min_{z\in\mathbb{R}^n}\{L_{\sigma_r}(y^{r,t}, z; x^{r,t})\}
= \frac{1}{\sigma_r}\!\left(\Pi_{\mathcal{C}}\!\big(x^{r,t}+\sigma_r(A^*y^{r,t}-c)\big)
 - \big(x^{r,t}+\sigma_r(A^*y^{r,t}-c)\big)\right).\]</div>
<p>The update of <span class="math notranslate nohighlight">\(x^{r,t+1}\)</span> is:</p>
<div class="math notranslate nohighlight">
\[x^{r,t+1}
= x^{r,t} + \sigma_r\!\left(A^*y^{r,t} + z^{r,t+1} - c\right)
= \Pi_{\mathcal{C}}\!\big(x^{r,t}+\sigma_r(A^*y^{r,t}-c)\big).\]</div>
<p>For general LP problems, set <span class="math notranslate nohighlight">\(\mathcal{T}_1=\lambda I_m- AA^*\)</span> with <span class="math notranslate nohighlight">\(\lambda \ge \lambda_1(AA^*)\)</span> in HPR-LP. The update for <span class="math notranslate nohighlight">\(y^{r,t+1}\)</span> is:</p>
<div class="math notranslate nohighlight">
\[y^{r, t+1} \;=\; \frac{1}{\sigma_r \lambda_A}\Big( \Pi_{\mathcal{K}}(R_y) - R_y \Big),\]</div>
<p>where <span class="math notranslate nohighlight">\(R_y := A\big(2x^{r, t+1} - x^{r,t}\big) - \sigma_r \lambda_A y^{r,t}.\)</span> Combining these relations shows <span class="math notranslate nohighlight">\(z^{r,t+1}\)</span> need not be computed at every step; it is only required when checking termination. Each step reduces to SpMV, vector operations, and simple projections, with per-iteration cost <span class="math notranslate nohighlight">\(O(\mathrm{nnz}(A))\)</span>.</p>
<p>On GPUs, these operations are mapped to custom CUDA kernels. Matrix–vector products use <strong><code class="docutils literal notranslate"><span class="pre">cusparseSpMV()</span></code></strong> with <strong><code class="docutils literal notranslate"><span class="pre">CUSPARSE_SPMV_CSR_ALG2</span></code></strong> for deterministic results.</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="../index.html" class="btn btn-neutral float-left" title="HPR-LP Solver" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="../Quick%20start%20guide/index.html" class="btn btn-neutral float-right" title="Quick start guide" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, HPR Methods Developer Team.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>